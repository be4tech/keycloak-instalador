"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ViewPortAdapter = exports.chromeFontSizesFactors = exports.getIsPortraitOrientation = exports.useViewPortState = exports.ViewPortOutOfRangeError = void 0;
var jsx_runtime_1 = require("react/jsx-runtime");
var react_1 = require("react");
var useGuaranteedMemo_1 = require("./useGuaranteedMemo");
var useWindowInnerSize_1 = require("./tools/useWindowInnerSize");
var useBrowserFontSizeFactor_1 = require("./tools/useBrowserFontSizeFactor");
var react_2 = require("react");
var ViewPortOutOfRangeError = /** @class */ (function (_super) {
    __extends(ViewPortOutOfRangeError, _super);
    function ViewPortOutOfRangeError(fallbackNode) {
        var _newTarget = this.constructor;
        var _this = _super.call(this) || this;
        _this.fallbackNode = fallbackNode;
        Object.setPrototypeOf(_this, _newTarget.prototype);
        return _this;
    }
    return ViewPortOutOfRangeError;
}(Error));
exports.ViewPortOutOfRangeError = ViewPortOutOfRangeError;
var reactContext = (function () {
    var propertyKey = "__powerhooks_ViewPortAdapter_context";
    var peerDepObj = react_2.createContext;
    var sharedContext = peerDepObj["__powerhooks_ViewPortAdapter_context"];
    if (sharedContext === undefined) {
        sharedContext = {
            "reactContext": (0, react_2.createContext)(undefined)
        };
        Object.defineProperty(peerDepObj, propertyKey, {
            "configurable": false,
            "enumerable": false,
            "writable": false,
            "value": sharedContext
        });
    }
    return sharedContext;
})().reactContext;
function useViewPortState() {
    var viewPortState = (0, react_2.useContext)(reactContext);
    return { viewPortState: viewPortState };
}
exports.useViewPortState = useViewPortState;
function getIsPortraitOrientation(props) {
    var windowInnerWidth = props.windowInnerWidth, windowInnerHeight = props.windowInnerHeight;
    var isPortraitOrientation = windowInnerWidth * 1.3 < windowInnerHeight;
    return isPortraitOrientation;
}
exports.getIsPortraitOrientation = getIsPortraitOrientation;
exports.chromeFontSizesFactors = {
    "Very small": 0.5625,
    "Small": 0.75,
    "Medium (Recommended)": 1,
    "Large": 1.25,
    "Very Large": 1.5,
};
/**
 * WARNING: We assumes that html element font-size is not defined
 * or defined in percentages.
 */
function ViewPortAdapter(props) {
    var getConfig = props.getConfig, children = props.children;
    var _a = (0, useWindowInnerSize_1.useWindowInnerSize)(), windowInnerWidth = _a.windowInnerWidth, windowInnerHeight = _a.windowInnerHeight;
    var browserFontSizeFactor = (0, useBrowserFontSizeFactor_1.useBrowserFontSizeFactor)().browserFontSizeFactor;
    var getConfigResult = (function useClosure() {
        var getConfigResultRef = (0, react_1.useRef)();
        (0, useGuaranteedMemo_1.useGuaranteedMemo)(function () {
            //We skip refresh when pinch and zoom
            if (getConfigResultRef.current !== undefined &&
                (window.scrollY !== 0 ||
                    window.scrollX !== 0)) {
                return;
            }
            var viewPortConfig;
            try {
                viewPortConfig = getConfig({
                    windowInnerWidth: windowInnerWidth,
                    windowInnerHeight: windowInnerHeight,
                    browserFontSizeFactor: browserFontSizeFactor
                });
            }
            catch (error) {
                if (!(error instanceof ViewPortOutOfRangeError)) {
                    throw error;
                }
                var fallbackNode = error.fallbackNode;
                getConfigResultRef.current = {
                    "isOutOfRange": true,
                    fallbackNode: fallbackNode
                };
                return;
            }
            var zoomFactor = windowInnerWidth / viewPortConfig.targetWindowInnerWidth;
            var viewPortState = __assign(__assign({}, viewPortConfig), { zoomFactor: zoomFactor, "targetWindowInnerHeight": windowInnerHeight / zoomFactor });
            getConfigResultRef.current = { "isOutOfRange": false, viewPortState: viewPortState };
        }, [
            getConfig,
            windowInnerWidth,
            windowInnerHeight,
            browserFontSizeFactor
        ]);
        return { "getConfigResult": getConfigResultRef.current };
    })().getConfigResult;
    (0, react_2.useEffect)(function () {
        if (getConfigResult.isOutOfRange) {
            return;
        }
        var viewPortState = getConfigResult.viewPortState;
        //NOTE: We assert the font size is defined in percent 
        //or not defined. We have no way to check it so we make
        //it a requirement to use the view port adapter.
        var rootElement = document.querySelector("html");
        var rootElementFontSizePx = parseInt(window.getComputedStyle(rootElement, null)
            .getPropertyValue("font-size")
            .replace(/px$/, ""));
        //Cross multiplication
        //100     						16 * browserFontSizeFactor;
        //rootElementFontSizeInPercent  rootElementFontSizePx
        var rootElementFontSizeInPercent = (100 * rootElementFontSizePx) / (16 * browserFontSizeFactor);
        rootElement.style.fontSize =
            "".concat(16 * (rootElementFontSizeInPercent / 100) * viewPortState.targetBrowserFontSizeFactor, "px");
    }, [
        browserFontSizeFactor,
        getConfigResult.isOutOfRange ?
            Object : getConfigResult.viewPortState.targetBrowserFontSizeFactor
    ]);
    if (getConfigResult.isOutOfRange) {
        var fallbackNode = getConfigResult.fallbackNode;
        return (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: fallbackNode });
    }
    var viewPortState = getConfigResult.viewPortState;
    return ((0, jsx_runtime_1.jsx)("div", __assign({ about: "powerhooks ".concat(ViewPortAdapter.name, " outer wrapper"), style: { "height": "100vh", "overflow": "hidden" } }, { children: (0, jsx_runtime_1.jsx)("div", __assign({ about: "powerhooks ".concat(ViewPortAdapter.name, " inner wrapper"), style: {
                "transform": "scale(".concat(viewPortState.zoomFactor, ")"),
                "transformOrigin": "0 0",
                "width": viewPortState.targetWindowInnerWidth,
                "height": viewPortState.targetWindowInnerHeight,
                "overflow": "hidden"
            } }, { children: (0, jsx_runtime_1.jsx)(reactContext.Provider, __assign({ value: viewPortState }, { children: children })) })) })));
}
exports.ViewPortAdapter = ViewPortAdapter;
//# sourceMappingURL=ViewPortAdapter.js.map