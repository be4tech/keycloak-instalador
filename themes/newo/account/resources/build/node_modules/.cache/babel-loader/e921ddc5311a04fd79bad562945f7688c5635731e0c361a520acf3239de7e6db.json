{"ast":null,"code":"var _jsxFileName = \"/Users/user/NewoDev/keycloakify-starter/src/App/oidc.tsx\",\n  _s2 = $RefreshSig$();\nimport { useState, useContext, createContext, useEffect } from \"react\";\nimport Keycloak_js from \"keycloak-js\";\nimport { id } from \"tsafe/id\";\nimport { addParamToUrl } from \"powerhooks/tools/urlSearchParams\";\nimport { assert } from \"tsafe/assert\";\nimport { createKeycloakAdapter } from \"keycloakify\";\nimport jwt_decode from \"jwt-decode\";\nimport { Evt } from \"evt\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nasync function createKeycloakOidcClient(params) {\n  const {\n    url,\n    realm,\n    clientId,\n    transformUrlBeforeRedirect,\n    getUiLocales,\n    log\n  } = params;\n  const keycloakInstance = new Keycloak_js({\n    url,\n    realm,\n    clientId\n  });\n  let redirectMethod = \"overwrite location.href\";\n  const isAuthenticated = await keycloakInstance.init({\n    onLoad: \"check-sso\",\n    silentCheckSsoRedirectUri: `${window.location.origin}/silent-sso.html`,\n    responseMode: \"query\",\n    checkLoginIframe: false,\n    adapter: createKeycloakAdapter({\n      transformUrlBeforeRedirect: url => [url].map(transformUrlBeforeRedirect !== null && transformUrlBeforeRedirect !== void 0 ? transformUrlBeforeRedirect : url => url).map(getUiLocales === undefined ? url => url : url => addParamToUrl({\n        url,\n        \"name\": \"ui_locales\",\n        \"value\": getUiLocales()\n      }).newUrl)[0],\n      keycloakInstance,\n      getRedirectMethod: () => redirectMethod\n    })\n  }).catch(error => error);\n\n  //TODO: Make sure that result is always an object.\n  if (isAuthenticated instanceof Error) {\n    throw isAuthenticated;\n  }\n  const login = async _ref => {\n    let {\n      doesCurrentHrefRequiresAuth\n    } = _ref;\n    if (doesCurrentHrefRequiresAuth) {\n      redirectMethod = \"location.replace\";\n    }\n    await keycloakInstance.login({\n      \"redirectUri\": window.location.href\n    });\n    return new Promise(() => {});\n  };\n  if (!isAuthenticated) {\n    return id({\n      \"isUserLoggedIn\": false,\n      login\n    });\n  }\n  let currentAccessToken = keycloakInstance.token;\n  const oidcClient = id({\n    \"isUserLoggedIn\": true,\n    \"getAccessToken\": () => currentAccessToken,\n    \"logout\": async _ref2 => {\n      let {\n        redirectTo\n      } = _ref2;\n      await keycloakInstance.logout({\n        \"redirectUri\": (() => {\n          switch (redirectTo) {\n            case \"current page\":\n              return window.location.href;\n            case \"home\":\n              return window.location.origin;\n          }\n        })()\n      });\n      return new Promise(() => {});\n    },\n    \"updateTokenInfos\": async () => {\n      await keycloakInstance.updateToken(-1);\n      currentAccessToken = keycloakInstance.token;\n    }\n  });\n  (function callee() {\n    const msBeforeExpiration = jwt_decode(currentAccessToken)[\"exp\"] * 1000 - Date.now();\n    setTimeout(async () => {\n      log === null || log === void 0 ? void 0 : log(`OIDC access token will expire in ${minValiditySecond} seconds, waiting for user activity before renewing`);\n      await Evt.merge([Evt.from(document, \"mousemove\"), Evt.from(document, \"keydown\")]).waitFor();\n      log === null || log === void 0 ? void 0 : log(\"User activity detected. Refreshing access token now\");\n      const error = await keycloakInstance.updateToken(-1).then(() => undefined, error => error);\n      if (error) {\n        log === null || log === void 0 ? void 0 : log(\"Can't refresh OIDC access token, getting a new one\");\n        //NOTE: Never resolves\n        await login({\n          \"doesCurrentHrefRequiresAuth\": true\n        });\n      }\n      currentAccessToken = keycloakInstance.token;\n      callee();\n    }, msBeforeExpiration - minValiditySecond * 1000);\n  })();\n  return oidcClient;\n}\nconst minValiditySecond = 25;\nconst oidcClientContext = /*#__PURE__*/createContext(undefined);\nexport function createOidcClientProvider(params) {\n  var _s = $RefreshSig$();\n  const prOidcClient = createKeycloakOidcClient(params);\n  function OidcClientProvider(props) {\n    _s();\n    const {\n      children\n    } = props;\n    const [oidcClient, setOidcClient] = useState(undefined);\n    useEffect(() => {\n      prOidcClient.then(setOidcClient);\n    }, []);\n    if (oidcClient === undefined) {\n      return null;\n    }\n    return /*#__PURE__*/_jsxDEV(oidcClientContext.Provider, {\n      value: oidcClient,\n      children: children\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 198,\n      columnNumber: 13\n    }, this);\n  }\n  _s(OidcClientProvider, \"N5jiT1PMV+c3qEyW9EuZGHQl1gg=\");\n  return {\n    OidcClientProvider\n  };\n}\nexport function useOidcClient() {\n  _s2();\n  const oidcClient = useContext(oidcClientContext);\n  assert(oidcClient !== undefined);\n  return {\n    oidcClient\n  };\n}\n_s2(useOidcClient, \"cwzwjGmPxnHILKr9hbeoGzrLtgE=\");","map":{"version":3,"names":["useState","useContext","createContext","useEffect","Keycloak_js","id","addParamToUrl","assert","createKeycloakAdapter","jwt_decode","Evt","jsxDEV","_jsxDEV","createKeycloakOidcClient","params","url","realm","clientId","transformUrlBeforeRedirect","getUiLocales","log","keycloakInstance","redirectMethod","isAuthenticated","init","onLoad","silentCheckSsoRedirectUri","window","location","origin","responseMode","checkLoginIframe","adapter","map","undefined","newUrl","getRedirectMethod","catch","error","Error","login","_ref","doesCurrentHrefRequiresAuth","href","Promise","currentAccessToken","token","oidcClient","getAccessToken","_ref2","redirectTo","logout","updateTokenInfos","updateToken","callee","msBeforeExpiration","Date","now","setTimeout","minValiditySecond","merge","from","document","waitFor","then","oidcClientContext","createOidcClientProvider","_s","$RefreshSig$","prOidcClient","OidcClientProvider","props","children","setOidcClient","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","useOidcClient","_s2"],"sources":["/Users/user/NewoDev/keycloakify-starter/src/App/oidc.tsx"],"sourcesContent":["import { useState, useContext, createContext, useEffect } from \"react\";\nimport Keycloak_js from \"keycloak-js\";\nimport { id } from \"tsafe/id\";\nimport { addParamToUrl } from \"powerhooks/tools/urlSearchParams\";\nimport type { ReturnType } from \"tsafe/ReturnType\";\nimport type { Param0 } from \"tsafe/Param0\";\nimport { assert } from \"tsafe/assert\";\nimport { createKeycloakAdapter } from \"keycloakify\";\nimport jwt_decode from \"jwt-decode\";\nimport { Evt } from \"evt\";\n\nexport declare type OidcClient = OidcClient.LoggedIn | OidcClient.NotLoggedIn;\n\nexport declare namespace OidcClient {\n    export type NotLoggedIn = {\n        isUserLoggedIn: false;\n        login: (params: {\n            //To prevent infinite loop if the user access a page that requires to\n            //be authenticated but cancel (clicks back). \n            doesCurrentHrefRequiresAuth: boolean;\n        }) => Promise<never>;\n    };\n\n    export type LoggedIn = {\n        isUserLoggedIn: true;\n        getAccessToken: () => string;\n        logout: (params: { redirectTo: \"home\" | \"current page\" }) => Promise<never>;\n        //If we have sent a API request to change user's email for example\n        //and we want that jwt_decode(oidcClient.getAccessToken()).email be the new email\n        //in this case we would call this method...\n        updateTokenInfos: () => Promise<void>;\n    };\n}\n\ntype Params = {\n    url: string;\n    realm: string;\n    clientId: string;\n    transformUrlBeforeRedirect?: (url: string) => string;\n    getUiLocales?: () => string;\n    log?: typeof console.log;\n};\n\nasync function createKeycloakOidcClient(params: Params): Promise<OidcClient> {\n    const {\n        url,\n        realm,\n        clientId,\n        transformUrlBeforeRedirect,\n        getUiLocales,\n        log\n    } = params;\n\n    const keycloakInstance = new Keycloak_js({ url, realm, clientId });\n\n    let redirectMethod: ReturnType<\n        Param0<typeof createKeycloakAdapter>[\"getRedirectMethod\"]\n    > = \"overwrite location.href\";\n\n    const isAuthenticated = await keycloakInstance\n        .init({\n            onLoad: \"check-sso\",\n            silentCheckSsoRedirectUri: `${window.location.origin}/silent-sso.html`,\n            responseMode: \"query\",\n            checkLoginIframe: false,\n            adapter: createKeycloakAdapter({\n                transformUrlBeforeRedirect: url =>\n                    [url]\n                        .map(transformUrlBeforeRedirect ?? (url => url))\n                        .map(\n                            getUiLocales === undefined ?\n                                (url => url) :\n                                url =>\n                                    addParamToUrl({\n                                        url,\n                                        \"name\": \"ui_locales\",\n                                        \"value\": getUiLocales()\n                                    }).newUrl\n                        )\n                    [0],\n                keycloakInstance,\n                getRedirectMethod: () => redirectMethod\n            })\n        })\n        .catch((error: Error) => error);\n\n    //TODO: Make sure that result is always an object.\n    if (isAuthenticated instanceof Error) {\n        throw isAuthenticated;\n    }\n\n    const login: OidcClient.NotLoggedIn[\"login\"] = async ({\n        doesCurrentHrefRequiresAuth\n    }) => {\n        if (doesCurrentHrefRequiresAuth) {\n            redirectMethod = \"location.replace\";\n        }\n\n        await keycloakInstance.login({ \"redirectUri\": window.location.href });\n\n        return new Promise<never>(() => { });\n    };\n\n    if (!isAuthenticated) {\n        return id<OidcClient.NotLoggedIn>({\n            \"isUserLoggedIn\": false,\n            login\n        });\n    }\n\n    let currentAccessToken = keycloakInstance.token!;\n\n    const oidcClient = id<OidcClient.LoggedIn>({\n        \"isUserLoggedIn\": true,\n        \"getAccessToken\": () => currentAccessToken,\n        \"logout\": async ({ redirectTo }) => {\n            await keycloakInstance.logout({\n                \"redirectUri\": (() => {\n                    switch (redirectTo) {\n                        case \"current page\":\n                            return window.location.href;\n                        case \"home\":\n                            return window.location.origin;\n                    }\n                })()\n            });\n\n            return new Promise<never>(() => { });\n        },\n        \"updateTokenInfos\": async () => {\n            await keycloakInstance.updateToken(-1);\n\n            currentAccessToken = keycloakInstance.token!;\n        }\n    });\n\n    (function callee() {\n        const msBeforeExpiration = jwt_decode<{ exp: number }>(currentAccessToken)[\"exp\"] * 1000 - Date.now();\n\n        setTimeout(async () => {\n\n            log?.(`OIDC access token will expire in ${minValiditySecond} seconds, waiting for user activity before renewing`);\n\n            await Evt.merge([\n                Evt.from(document, \"mousemove\"),\n                Evt.from(document, \"keydown\")\n            ]).waitFor();\n\n            log?.(\"User activity detected. Refreshing access token now\");\n\n            const error = await keycloakInstance.updateToken(-1).then(\n                () => undefined,\n                (error: Error) => error\n            );\n\n            if (error) {\n                log?.(\"Can't refresh OIDC access token, getting a new one\");\n                //NOTE: Never resolves\n                await login({ \"doesCurrentHrefRequiresAuth\": true });\n            }\n\n            currentAccessToken = keycloakInstance.token!;\n\n            callee();\n\n        }, msBeforeExpiration - minValiditySecond * 1000);\n    })();\n\n    return oidcClient;\n}\n\nconst minValiditySecond = 25;\n\nconst oidcClientContext = createContext<OidcClient | undefined>(undefined);\n\nexport function createOidcClientProvider(params: Params) {\n\n\n    const prOidcClient = createKeycloakOidcClient(params);\n\n    function OidcClientProvider(props: { children: React.ReactNode; }) {\n\n        const { children } = props;\n\n        const [oidcClient, setOidcClient] = useState<OidcClient | undefined>(undefined);\n\n        useEffect(() => {\n\n            prOidcClient.then(setOidcClient);\n\n        }, []);\n\n        if (oidcClient === undefined) {\n            return null;\n        }\n\n        return (\n            <oidcClientContext.Provider value={oidcClient}>\n                {children}\n            </oidcClientContext.Provider>\n        );\n\n    }\n\n    return { OidcClientProvider };\n\n}\n\nexport function useOidcClient() {\n    const oidcClient = useContext(oidcClientContext);\n    assert(oidcClient !== undefined);\n    return { oidcClient };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}