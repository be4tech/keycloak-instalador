{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\nimport \"../../tools/Array.prototype.every\";\nimport { useMemo, useReducer, Fragment } from \"react\";\nimport { id } from \"tsafe/id\";\nimport { useConstCallback } from \"../../tools/useConstCallback\";\nimport { emailRegexp } from \"../../tools/emailRegExp\";\n/**\n * NOTE: The attributesWithPassword returned is actually augmented with\n * artificial password related attributes only if kcContext.passwordRequired === true\n */\nexport function useFormValidation(params) {\n  const {\n    kcContext,\n    passwordValidators = {\n      \"length\": {\n        \"ignore.empty.value\": true,\n        \"min\": \"4\"\n      }\n    },\n    i18n\n  } = params;\n  const attributesWithPassword = useMemo(() => !kcContext.passwordRequired ? kcContext.profile.attributes : (() => {\n    const name = kcContext.realm.registrationEmailAsUsername ? \"email\" : \"username\";\n    return kcContext.profile.attributes.reduce((prev, curr) => [...prev, ...(curr.name !== name ? [curr] : [curr, id({\n      \"name\": \"password\",\n      \"displayName\": id(\"${password}\"),\n      \"required\": true,\n      \"readOnly\": false,\n      \"validators\": passwordValidators,\n      \"annotations\": {},\n      \"groupAnnotations\": {},\n      \"autocomplete\": \"new-password\"\n    }), id({\n      \"name\": \"password-confirm\",\n      \"displayName\": id(\"${passwordConfirm}\"),\n      \"required\": true,\n      \"readOnly\": false,\n      \"validators\": {\n        \"_compareToOther\": {\n          \"name\": \"password\",\n          \"ignore.empty.value\": true,\n          \"shouldBe\": \"equal\",\n          \"error-message\": id(\"${invalidPasswordConfirmMessage}\")\n        }\n      },\n      \"annotations\": {},\n      \"groupAnnotations\": {},\n      \"autocomplete\": \"new-password\"\n    })])], []);\n  })(), [kcContext, passwordValidators]);\n  const {\n    getErrors\n  } = useGetErrors({\n    \"kcContext\": {\n      \"messagesPerField\": kcContext.messagesPerField,\n      \"profile\": {\n        \"attributes\": attributesWithPassword\n      }\n    },\n    i18n\n  });\n  const initialInternalState = useMemo(() => Object.fromEntries(attributesWithPassword.map(attribute => ({\n    attribute,\n    \"errors\": getErrors({\n      \"name\": attribute.name,\n      \"fieldValueByAttributeName\": Object.fromEntries(attributesWithPassword.map(_ref => {\n        let {\n          name,\n          value\n        } = _ref;\n        return [name, {\n          \"value\": value !== null && value !== void 0 ? value : \"\"\n        }];\n      }))\n    })\n  })).map(_ref2 => {\n    let {\n      attribute,\n      errors\n    } = _ref2;\n    var _a;\n    return [attribute.name, {\n      \"value\": (_a = attribute.value) !== null && _a !== void 0 ? _a : \"\",\n      errors,\n      \"doDisplayPotentialErrorMessages\": errors.length !== 0\n    }];\n  })), [attributesWithPassword]);\n  const [formValidationInternalState, formValidationDispatch] = useReducer((state, params) => Object.assign(Object.assign({}, state), {\n    [params.name]: Object.assign(Object.assign({}, state[params.name]), (() => {\n      switch (params.action) {\n        case \"focus lost\":\n          return {\n            \"doDisplayPotentialErrorMessages\": true\n          };\n        case \"update value\":\n          return {\n            \"value\": params.newValue,\n            \"errors\": getErrors({\n              \"name\": params.name,\n              \"fieldValueByAttributeName\": Object.assign(Object.assign({}, state), {\n                [params.name]: {\n                  \"value\": params.newValue\n                }\n              })\n            })\n          };\n      }\n    })())\n  }), initialInternalState);\n  const formValidationState = useMemo(() => ({\n    \"fieldStateByAttributeName\": Object.fromEntries(Object.entries(formValidationInternalState).map(_ref3 => {\n      let [name, {\n        value,\n        errors,\n        doDisplayPotentialErrorMessages\n      }] = _ref3;\n      return [name, {\n        value,\n        \"displayableErrors\": doDisplayPotentialErrorMessages ? errors : []\n      }];\n    })),\n    \"isFormSubmittable\": Object.entries(formValidationInternalState).every(_ref4 => {\n      let [name, {\n        value,\n        errors\n      }] = _ref4;\n      return errors.length === 0 && (value !== \"\" || !attributesWithPassword.find(attribute => attribute.name === name).required);\n    })\n  }), [formValidationInternalState, attributesWithPassword]);\n  return {\n    formValidationState,\n    formValidationDispatch,\n    attributesWithPassword\n  };\n}\n/** Expect to be used in a component wrapped within a <I18nProvider> */\nfunction useGetErrors(params) {\n  const {\n    kcContext,\n    i18n\n  } = params;\n  const {\n    messagesPerField,\n    profile: {\n      attributes\n    }\n  } = kcContext;\n  const {\n    msg,\n    msgStr,\n    advancedMsg,\n    advancedMsgStr\n  } = i18n;\n  const getErrors = useConstCallback(params => {\n    var _a;\n    const {\n      name,\n      fieldValueByAttributeName\n    } = params;\n    const {\n      value\n    } = fieldValueByAttributeName[name];\n    const {\n      value: defaultValue,\n      validators\n    } = attributes.find(attribute => attribute.name === name);\n    block: {\n      if (defaultValue !== value) {\n        break block;\n      }\n      let doesErrorExist;\n      try {\n        doesErrorExist = messagesPerField.existsError(name);\n      } catch (_b) {\n        break block;\n      }\n      if (!doesErrorExist) {\n        break block;\n      }\n      const errorMessageStr = messagesPerField.get(name);\n      return [{\n        \"validatorName\": undefined,\n        errorMessageStr,\n        \"errorMessage\": _jsx(\"span\", {\n          children: errorMessageStr\n        }, 0)\n      }];\n    }\n    const errors = [];\n    scope: {\n      const validatorName = \"length\";\n      const validator = validators[validatorName];\n      if (validator === undefined) {\n        break scope;\n      }\n      const {\n        \"ignore.empty.value\": ignoreEmptyValue = false,\n        max,\n        min\n      } = validator;\n      if (ignoreEmptyValue && value === \"\") {\n        break scope;\n      }\n      if (max !== undefined && value.length > parseInt(max)) {\n        const msgArgs = [\"error-invalid-length-too-long\", max];\n        errors.push({\n          \"errorMessage\": _jsx(Fragment, {\n            children: msg(...msgArgs)\n          }, errors.length),\n          \"errorMessageStr\": msgStr(...msgArgs),\n          validatorName\n        });\n      }\n      if (min !== undefined && value.length < parseInt(min)) {\n        const msgArgs = [\"error-invalid-length-too-short\", min];\n        errors.push({\n          \"errorMessage\": _jsx(Fragment, {\n            children: msg(...msgArgs)\n          }, errors.length),\n          \"errorMessageStr\": msgStr(...msgArgs),\n          validatorName\n        });\n      }\n    }\n    scope: {\n      const validatorName = \"_compareToOther\";\n      const validator = validators[validatorName];\n      if (validator === undefined) {\n        break scope;\n      }\n      const {\n        \"ignore.empty.value\": ignoreEmptyValue = false,\n        name: otherName,\n        shouldBe,\n        \"error-message\": errorMessageKey\n      } = validator;\n      if (ignoreEmptyValue && value === \"\") {\n        break scope;\n      }\n      const {\n        value: otherValue\n      } = fieldValueByAttributeName[otherName];\n      const isValid = (() => {\n        switch (shouldBe) {\n          case \"different\":\n            return otherValue !== value;\n          case \"equal\":\n            return otherValue === value;\n        }\n      })();\n      if (isValid) {\n        break scope;\n      }\n      const msgArg = [errorMessageKey !== null && errorMessageKey !== void 0 ? errorMessageKey : id((() => {\n        switch (shouldBe) {\n          case \"equal\":\n            return \"shouldBeEqual\";\n          case \"different\":\n            return \"shouldBeDifferent\";\n        }\n      })()), otherName, name, shouldBe];\n      errors.push({\n        validatorName,\n        \"errorMessage\": _jsx(Fragment, {\n          children: advancedMsg(...msgArg)\n        }, errors.length),\n        \"errorMessageStr\": advancedMsgStr(...msgArg)\n      });\n    }\n    scope: {\n      const validatorName = \"pattern\";\n      const validator = validators[validatorName];\n      if (validator === undefined) {\n        break scope;\n      }\n      const {\n        \"ignore.empty.value\": ignoreEmptyValue = false,\n        pattern,\n        \"error-message\": errorMessageKey\n      } = validator;\n      if (ignoreEmptyValue && value === \"\") {\n        break scope;\n      }\n      if (new RegExp(pattern).test(value)) {\n        break scope;\n      }\n      const msgArgs = [errorMessageKey !== null && errorMessageKey !== void 0 ? errorMessageKey : id(\"shouldMatchPattern\"), pattern];\n      errors.push({\n        validatorName,\n        \"errorMessage\": _jsx(Fragment, {\n          children: advancedMsg(...msgArgs)\n        }, errors.length),\n        \"errorMessageStr\": advancedMsgStr(...msgArgs)\n      });\n    }\n    scope: {\n      if (((_a = [...errors].reverse()[0]) === null || _a === void 0 ? void 0 : _a.validatorName) === \"pattern\") {\n        break scope;\n      }\n      const validatorName = \"email\";\n      const validator = validators[validatorName];\n      if (validator === undefined) {\n        break scope;\n      }\n      const {\n        \"ignore.empty.value\": ignoreEmptyValue = false\n      } = validator;\n      if (ignoreEmptyValue && value === \"\") {\n        break scope;\n      }\n      if (emailRegexp.test(value)) {\n        break scope;\n      }\n      const msgArgs = [id(\"invalidEmailMessage\")];\n      errors.push({\n        validatorName,\n        \"errorMessage\": _jsx(Fragment, {\n          children: msg(...msgArgs)\n        }, errors.length),\n        \"errorMessageStr\": msgStr(...msgArgs)\n      });\n    }\n    scope: {\n      const validatorName = \"integer\";\n      const validator = validators[validatorName];\n      if (validator === undefined) {\n        break scope;\n      }\n      const {\n        \"ignore.empty.value\": ignoreEmptyValue = false,\n        max,\n        min\n      } = validator;\n      if (ignoreEmptyValue && value === \"\") {\n        break scope;\n      }\n      const intValue = parseInt(value);\n      if (isNaN(intValue)) {\n        const msgArgs = [\"mustBeAnInteger\"];\n        errors.push({\n          validatorName,\n          \"errorMessage\": _jsx(Fragment, {\n            children: msg(...msgArgs)\n          }, errors.length),\n          \"errorMessageStr\": msgStr(...msgArgs)\n        });\n        break scope;\n      }\n      if (max !== undefined && intValue > parseInt(max)) {\n        const msgArgs = [\"error-number-out-of-range-too-big\", max];\n        errors.push({\n          validatorName,\n          \"errorMessage\": _jsx(Fragment, {\n            children: msg(...msgArgs)\n          }, errors.length),\n          \"errorMessageStr\": msgStr(...msgArgs)\n        });\n        break scope;\n      }\n      if (min !== undefined && intValue < parseInt(min)) {\n        const msgArgs = [\"error-number-out-of-range-too-small\", min];\n        errors.push({\n          validatorName,\n          \"errorMessage\": _jsx(Fragment, {\n            children: msg(...msgArgs)\n          }, errors.length),\n          \"errorMessageStr\": msgStr(...msgArgs)\n        });\n        break scope;\n      }\n    }\n    scope: {\n      const validatorName = \"options\";\n      const validator = validators[validatorName];\n      if (validator === undefined) {\n        break scope;\n      }\n      if (value === \"\") {\n        break scope;\n      }\n      if (validator.options.indexOf(value) >= 0) {\n        break scope;\n      }\n      const msgArgs = [id(\"notAValidOption\")];\n      errors.push({\n        validatorName,\n        \"errorMessage\": _jsx(Fragment, {\n          children: advancedMsg(...msgArgs)\n        }, errors.length),\n        \"errorMessageStr\": advancedMsgStr(...msgArgs)\n      });\n    }\n    //TODO: Implement missing validators.\n    return errors;\n  });\n  return {\n    getErrors\n  };\n}","map":{"version":3,"names":["useMemo","useReducer","Fragment","id","useConstCallback","emailRegexp","useFormValidation","params","kcContext","passwordValidators","i18n","attributesWithPassword","passwordRequired","profile","attributes","name","realm","registrationEmailAsUsername","reduce","prev","curr","getErrors","useGetErrors","messagesPerField","initialInternalState","Object","fromEntries","map","attribute","_ref","value","_ref2","errors","_a","length","formValidationInternalState","formValidationDispatch","state","assign","action","newValue","formValidationState","entries","_ref3","doDisplayPotentialErrorMessages","every","_ref4","find","required","msg","msgStr","advancedMsg","advancedMsgStr","fieldValueByAttributeName","defaultValue","validators","block","doesErrorExist","existsError","_b","errorMessageStr","get","undefined","_jsx","children","scope","validatorName","validator","ignoreEmptyValue","max","min","parseInt","msgArgs","push","otherName","shouldBe","errorMessageKey","otherValue","isValid","msgArg","pattern","RegExp","test","reverse","intValue","isNaN","options","indexOf"],"sources":["/Users/user/NewoDev/keycloakify-starter/node_modules/keycloakify/src/login/lib/useFormValidation.tsx"],"sourcesContent":["import \"keycloakify/tools/Array.prototype.every\";\nimport { useMemo, useReducer, Fragment } from \"react\";\nimport { id } from \"tsafe/id\";\nimport type { MessageKey } from \"keycloakify/login/i18n/i18n\";\nimport type { Attribute, Validators } from \"keycloakify/login/kcContext/KcContext\";\nimport { useConstCallback } from \"keycloakify/tools/useConstCallback\";\nimport { emailRegexp } from \"keycloakify/tools/emailRegExp\";\nimport type { KcContext } from \"../kcContext\";\nimport type { I18n } from \"../i18n\";\n\n/**\n * NOTE: The attributesWithPassword returned is actually augmented with\n * artificial password related attributes only if kcContext.passwordRequired === true\n */\nexport function useFormValidation(params: {\n    kcContext: {\n        messagesPerField: Pick<KcContext.Common[\"messagesPerField\"], \"existsError\" | \"get\">;\n        profile: {\n            attributes: Attribute[];\n        };\n        passwordRequired?: boolean;\n        realm: { registrationEmailAsUsername: boolean };\n    };\n    /** NOTE: Try to avoid passing a new ref every render for better performances. */\n    passwordValidators?: Validators;\n    i18n: I18n;\n}) {\n    const {\n        kcContext,\n        passwordValidators = {\n            \"length\": {\n                \"ignore.empty.value\": true,\n                \"min\": \"4\"\n            }\n        },\n        i18n\n    } = params;\n\n    const attributesWithPassword = useMemo(\n        () =>\n            !kcContext.passwordRequired\n                ? kcContext.profile.attributes\n                : (() => {\n                      const name = kcContext.realm.registrationEmailAsUsername ? \"email\" : \"username\";\n\n                      return kcContext.profile.attributes.reduce<Attribute[]>(\n                          (prev, curr) => [\n                              ...prev,\n                              ...(curr.name !== name\n                                  ? [curr]\n                                  : [\n                                        curr,\n                                        id<Attribute>({\n                                            \"name\": \"password\",\n                                            \"displayName\": id<`\\${${MessageKey}}`>(\"${password}\"),\n                                            \"required\": true,\n                                            \"readOnly\": false,\n                                            \"validators\": passwordValidators,\n                                            \"annotations\": {},\n                                            \"groupAnnotations\": {},\n                                            \"autocomplete\": \"new-password\"\n                                        }),\n                                        id<Attribute>({\n                                            \"name\": \"password-confirm\",\n                                            \"displayName\": id<`\\${${MessageKey}}`>(\"${passwordConfirm}\"),\n                                            \"required\": true,\n                                            \"readOnly\": false,\n                                            \"validators\": {\n                                                \"_compareToOther\": {\n                                                    \"name\": \"password\",\n                                                    \"ignore.empty.value\": true,\n                                                    \"shouldBe\": \"equal\",\n                                                    \"error-message\": id<`\\${${MessageKey}}`>(\"${invalidPasswordConfirmMessage}\")\n                                                }\n                                            },\n                                            \"annotations\": {},\n                                            \"groupAnnotations\": {},\n                                            \"autocomplete\": \"new-password\"\n                                        })\n                                    ])\n                          ],\n                          []\n                      );\n                  })(),\n        [kcContext, passwordValidators]\n    );\n\n    const { getErrors } = useGetErrors({\n        \"kcContext\": {\n            \"messagesPerField\": kcContext.messagesPerField,\n            \"profile\": {\n                \"attributes\": attributesWithPassword\n            }\n        },\n        i18n\n    });\n\n    const initialInternalState = useMemo(\n        () =>\n            Object.fromEntries(\n                attributesWithPassword\n                    .map(attribute => ({\n                        attribute,\n                        \"errors\": getErrors({\n                            \"name\": attribute.name,\n                            \"fieldValueByAttributeName\": Object.fromEntries(\n                                attributesWithPassword.map(({ name, value }) => [name, { \"value\": value ?? \"\" }])\n                            )\n                        })\n                    }))\n                    .map(({ attribute, errors }) => [\n                        attribute.name,\n                        {\n                            \"value\": attribute.value ?? \"\",\n                            errors,\n                            \"doDisplayPotentialErrorMessages\": errors.length !== 0\n                        }\n                    ])\n            ),\n        [attributesWithPassword]\n    );\n\n    type InternalState = typeof initialInternalState;\n\n    const [formValidationInternalState, formValidationDispatch] = useReducer(\n        (\n            state: InternalState,\n            params:\n                | {\n                      action: \"update value\";\n                      name: string;\n                      newValue: string;\n                  }\n                | {\n                      action: \"focus lost\";\n                      name: string;\n                  }\n        ): InternalState => ({\n            ...state,\n            [params.name]: {\n                ...state[params.name],\n                ...(() => {\n                    switch (params.action) {\n                        case \"focus lost\":\n                            return { \"doDisplayPotentialErrorMessages\": true };\n                        case \"update value\":\n                            return {\n                                \"value\": params.newValue,\n                                \"errors\": getErrors({\n                                    \"name\": params.name,\n                                    \"fieldValueByAttributeName\": {\n                                        ...state,\n                                        [params.name]: { \"value\": params.newValue }\n                                    }\n                                })\n                            };\n                    }\n                })()\n            }\n        }),\n        initialInternalState\n    );\n\n    const formValidationState = useMemo(\n        () => ({\n            \"fieldStateByAttributeName\": Object.fromEntries(\n                Object.entries(formValidationInternalState).map(([name, { value, errors, doDisplayPotentialErrorMessages }]) => [\n                    name,\n                    { value, \"displayableErrors\": doDisplayPotentialErrorMessages ? errors : [] }\n                ])\n            ),\n            \"isFormSubmittable\": Object.entries(formValidationInternalState).every(\n                ([name, { value, errors }]) =>\n                    errors.length === 0 && (value !== \"\" || !attributesWithPassword.find(attribute => attribute.name === name)!.required)\n            )\n        }),\n        [formValidationInternalState, attributesWithPassword]\n    );\n\n    return {\n        formValidationState,\n        formValidationDispatch,\n        attributesWithPassword\n    };\n}\n\n/** Expect to be used in a component wrapped within a <I18nProvider> */\nfunction useGetErrors(params: {\n    kcContext: {\n        messagesPerField: Pick<KcContext.Common[\"messagesPerField\"], \"existsError\" | \"get\">;\n        profile: {\n            attributes: { name: string; value?: string; validators: Validators }[];\n        };\n    };\n    i18n: I18n;\n}) {\n    const { kcContext, i18n } = params;\n\n    const {\n        messagesPerField,\n        profile: { attributes }\n    } = kcContext;\n\n    const { msg, msgStr, advancedMsg, advancedMsgStr } = i18n;\n\n    const getErrors = useConstCallback((params: { name: string; fieldValueByAttributeName: Record<string, { value: string }> }) => {\n        const { name, fieldValueByAttributeName } = params;\n\n        const { value } = fieldValueByAttributeName[name];\n\n        const { value: defaultValue, validators } = attributes.find(attribute => attribute.name === name)!;\n\n        block: {\n            if (defaultValue !== value) {\n                break block;\n            }\n\n            let doesErrorExist: boolean;\n\n            try {\n                doesErrorExist = messagesPerField.existsError(name);\n            } catch {\n                break block;\n            }\n\n            if (!doesErrorExist) {\n                break block;\n            }\n\n            const errorMessageStr = messagesPerField.get(name);\n\n            return [\n                {\n                    \"validatorName\": undefined,\n                    errorMessageStr,\n                    \"errorMessage\": <span key={0}>{errorMessageStr}</span>\n                }\n            ];\n        }\n\n        const errors: {\n            errorMessage: JSX.Element;\n            errorMessageStr: string;\n            validatorName: keyof Validators | undefined;\n        }[] = [];\n\n        scope: {\n            const validatorName = \"length\";\n\n            const validator = validators[validatorName];\n\n            if (validator === undefined) {\n                break scope;\n            }\n\n            const { \"ignore.empty.value\": ignoreEmptyValue = false, max, min } = validator;\n\n            if (ignoreEmptyValue && value === \"\") {\n                break scope;\n            }\n\n            if (max !== undefined && value.length > parseInt(max)) {\n                const msgArgs = [\"error-invalid-length-too-long\", max] as const;\n\n                errors.push({\n                    \"errorMessage\": <Fragment key={errors.length}>{msg(...msgArgs)}</Fragment>,\n                    \"errorMessageStr\": msgStr(...msgArgs),\n                    validatorName\n                });\n            }\n\n            if (min !== undefined && value.length < parseInt(min)) {\n                const msgArgs = [\"error-invalid-length-too-short\", min] as const;\n\n                errors.push({\n                    \"errorMessage\": <Fragment key={errors.length}>{msg(...msgArgs)}</Fragment>,\n                    \"errorMessageStr\": msgStr(...msgArgs),\n                    validatorName\n                });\n            }\n        }\n\n        scope: {\n            const validatorName = \"_compareToOther\";\n\n            const validator = validators[validatorName];\n\n            if (validator === undefined) {\n                break scope;\n            }\n\n            const { \"ignore.empty.value\": ignoreEmptyValue = false, name: otherName, shouldBe, \"error-message\": errorMessageKey } = validator;\n\n            if (ignoreEmptyValue && value === \"\") {\n                break scope;\n            }\n\n            const { value: otherValue } = fieldValueByAttributeName[otherName];\n\n            const isValid = (() => {\n                switch (shouldBe) {\n                    case \"different\":\n                        return otherValue !== value;\n                    case \"equal\":\n                        return otherValue === value;\n                }\n            })();\n\n            if (isValid) {\n                break scope;\n            }\n\n            const msgArg = [\n                errorMessageKey ??\n                    id<MessageKey>(\n                        (() => {\n                            switch (shouldBe) {\n                                case \"equal\":\n                                    return \"shouldBeEqual\";\n                                case \"different\":\n                                    return \"shouldBeDifferent\";\n                            }\n                        })()\n                    ),\n                otherName,\n                name,\n                shouldBe\n            ] as const;\n\n            errors.push({\n                validatorName,\n                \"errorMessage\": <Fragment key={errors.length}>{advancedMsg(...msgArg)}</Fragment>,\n                \"errorMessageStr\": advancedMsgStr(...msgArg)\n            });\n        }\n\n        scope: {\n            const validatorName = \"pattern\";\n\n            const validator = validators[validatorName];\n\n            if (validator === undefined) {\n                break scope;\n            }\n\n            const { \"ignore.empty.value\": ignoreEmptyValue = false, pattern, \"error-message\": errorMessageKey } = validator;\n\n            if (ignoreEmptyValue && value === \"\") {\n                break scope;\n            }\n\n            if (new RegExp(pattern).test(value)) {\n                break scope;\n            }\n\n            const msgArgs = [errorMessageKey ?? id<MessageKey>(\"shouldMatchPattern\"), pattern] as const;\n\n            errors.push({\n                validatorName,\n                \"errorMessage\": <Fragment key={errors.length}>{advancedMsg(...msgArgs)}</Fragment>,\n                \"errorMessageStr\": advancedMsgStr(...msgArgs)\n            });\n        }\n\n        scope: {\n            if ([...errors].reverse()[0]?.validatorName === \"pattern\") {\n                break scope;\n            }\n\n            const validatorName = \"email\";\n\n            const validator = validators[validatorName];\n\n            if (validator === undefined) {\n                break scope;\n            }\n\n            const { \"ignore.empty.value\": ignoreEmptyValue = false } = validator;\n\n            if (ignoreEmptyValue && value === \"\") {\n                break scope;\n            }\n\n            if (emailRegexp.test(value)) {\n                break scope;\n            }\n\n            const msgArgs = [id<MessageKey>(\"invalidEmailMessage\")] as const;\n\n            errors.push({\n                validatorName,\n                \"errorMessage\": <Fragment key={errors.length}>{msg(...msgArgs)}</Fragment>,\n                \"errorMessageStr\": msgStr(...msgArgs)\n            });\n        }\n\n        scope: {\n            const validatorName = \"integer\";\n\n            const validator = validators[validatorName];\n\n            if (validator === undefined) {\n                break scope;\n            }\n\n            const { \"ignore.empty.value\": ignoreEmptyValue = false, max, min } = validator;\n\n            if (ignoreEmptyValue && value === \"\") {\n                break scope;\n            }\n\n            const intValue = parseInt(value);\n\n            if (isNaN(intValue)) {\n                const msgArgs = [\"mustBeAnInteger\"] as const;\n\n                errors.push({\n                    validatorName,\n                    \"errorMessage\": <Fragment key={errors.length}>{msg(...msgArgs)}</Fragment>,\n                    \"errorMessageStr\": msgStr(...msgArgs)\n                });\n\n                break scope;\n            }\n\n            if (max !== undefined && intValue > parseInt(max)) {\n                const msgArgs = [\"error-number-out-of-range-too-big\", max] as const;\n\n                errors.push({\n                    validatorName,\n                    \"errorMessage\": <Fragment key={errors.length}>{msg(...msgArgs)}</Fragment>,\n                    \"errorMessageStr\": msgStr(...msgArgs)\n                });\n\n                break scope;\n            }\n\n            if (min !== undefined && intValue < parseInt(min)) {\n                const msgArgs = [\"error-number-out-of-range-too-small\", min] as const;\n\n                errors.push({\n                    validatorName,\n                    \"errorMessage\": <Fragment key={errors.length}>{msg(...msgArgs)}</Fragment>,\n                    \"errorMessageStr\": msgStr(...msgArgs)\n                });\n\n                break scope;\n            }\n        }\n\n        scope: {\n            const validatorName = \"options\";\n\n            const validator = validators[validatorName];\n\n            if (validator === undefined) {\n                break scope;\n            }\n\n            if (value === \"\") {\n                break scope;\n            }\n\n            if (validator.options.indexOf(value) >= 0) {\n                break scope;\n            }\n\n            const msgArgs = [id<MessageKey>(\"notAValidOption\")] as const;\n\n            errors.push({\n                validatorName,\n                \"errorMessage\": <Fragment key={errors.length}>{advancedMsg(...msgArgs)}</Fragment>,\n                \"errorMessageStr\": advancedMsgStr(...msgArgs)\n            });\n        }\n\n        //TODO: Implement missing validators.\n\n        return errors;\n    });\n\n    return { getErrors };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}